# 贪吃蛇

功能介绍：
本贪吃蛇游戏主要分为三种模式——单人模式、双人模式、自动模式（补充）
（1）单人模式：在单人模式之下，只有一条主玩家main_snake，也会在游戏初始化的时候产生一条捕猎者hunting_snake，
该模式之下不涉及任何智能算法（好吧最后想了想还是决定让捕猎者采用广度优先算法去吃食物让游戏更有挑战性一点），完全靠玩家自己尽量去避免碰到捕猎者、周围的墙壁和自己的身体
该模式之下会出现虫洞，即玩家和捕食者都可以穿越虫洞到达虫洞的另一边
还会有加速键的功能，玩家按下加速键之后可以实现2倍速或3倍速，此时捕食者速度不变
当main_snake长度达到最大长度max_length的时候游戏胜利结束
（2）双人模式：在双人模式之下，有两名主玩家snake1与snake2，在游戏初始化的时候也会产生一条捕猎者hunting_snake，
保留单人模式之下的虫洞与加速键的玩法，两名玩家应避免蛇头碰到捕猎者、周围的墙壁和双方的身体
当某一方先死亡则另一方胜利，或者一方长度先达到最大长度max_length视为胜利
（3）自动模式（补充）：在自动模式当中，会出现两条AI小蛇，以及不确定性产生捕猎者
主要采用广度优先BFS算法与A*搜索算法对两条小蛇作路径规划，
从而做到既避免碰到对方又能以最快的速度与路径吃到食物，
但是该模式之下则会避免采用加速的方式，因为在AI互相对决之下都会尽可能采用最快的方式，
在该模式之下，仍然会保留虫洞这个增加趣味性的功能，
为了增加可观赏性，会提高游戏的帧率


环境配置：
需要调用pygame的包用于绘制UI界面
需要调用numpy模块来实现列表（向量、矩阵等）的快速生成


核心思路：
（1）初始化界面
（2）用numpy数组来存储要标亮的位置信息
（3）自动移动与加速移动
（4）随机生成食物
（5）生成虫洞
（6）生成捕猎者




对于A*算法的理解：
f=g+h
其中g为从蛇头到食物之间的实际成本（这里的实际成本就是从父节点走到这个方块需要的距离1），
h为蛇头到食物之间的估计成本（这里使用曼哈顿距离），
并将子节点加入到开放列表openlist中，将父节点加入到关闭列表closelist中之后就不再考虑这些结点
这里由于贪吃蛇只能够上下左右进行移动，因此每一次遍历只需要看上下左右那四个方块的离食物的距离
将上下左右四个方块的距离f更新为：1+新方块离食物之间的曼哈顿距离
并且开辟一个字典dict_node存储开放过的列表所有节点（键）指向的父节点（值）是什么
而且还要开辟一个字典dict_distance存储所有节点的距离f
每一次都挑距离最短的那个结点开辟新的周围几个节点
直到终点加入到开放列表openlist中，从终点开始通过dict_node回溯到起点
由于这个该算法是针对于hunting_snake的，不用考虑main_snake的存在，因此在单双人阶段是不用考虑要躲避其他蛇的
注意还需要考虑虫洞的存在，如果有遇到了虫洞直接将另一个出口也归并到开放列表openlist当中即可




遇到的问题：
①不知道为什么一旦加速起来会导致玩家吃到食物的时候会突然死亡，
通过用print方法debug之后才发现其实是因为移动得太快了导致判断其死亡的方式又是头是否碰到身体
之后冥思苦想想到一个“曲线救国”的策略，先删去前面四个方格（因为无论如何走都不可能碰到自己前四个方格）
当然这个只是一种治标不治本的方法，并不能改变仍然会出bug的可能性（事实上运行代码的时候确实会出现bug但也不知道怎么改）
